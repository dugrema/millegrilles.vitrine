#!/usr/bin/env node
const debug = require('debug')('millegrilles:vitrine:www')
const express = require('express')

const server4 = require('@dugrema/millegrilles.common/lib/server4')
const socketApp = require('../models/appSocketIo')

const vitrine = require('../routes/vitrine')
const { chargerMapping, chargerSections } = require('../models/siteDao')
const siteMessageHandler = require('../models/siteMessageHandler')
const preparerCode = require('../models/preparerCode')

async function init() {

  // Validations des variables au demarrage
  const noeudId = process.env.MG_NOEUD_ID
  if(!noeudId) throw new Error("Il faut fournir MG_NOEUD_ID")

  // Initialiser server et routes
  const app = express()

  const opts = {
    exchange: '1.public',
    pathApp: '/vitrine',
    public: true,  // Desactive authentification, socket.io verif headers
    socketIoCORS: {
      origin: "*",
      methods: ["GET", "POST"]
    },
  }
  const {server, socketIo, amqpdao} = await server4(app, socketApp.configurerEvenements, opts)

  await initialiserRoutingKeys(amqpdao, noeudId, socketIo)

  // Ajouter les routes
  const routeVitrine = vitrine()
  app.get('/vitrine/*', routeVitrine)

  // Lancer chargement async des sites (si echec, va reessayer durant la maintenance)
  initialiserDonnees(amqpdao, noeudId)

  // Copier le code de vitrine vers le repertoire approprie (e.g. nginx)
  preparerCode.init()
  preparerCode.copierCode()
    .catch(err=>{
      console.error("ERROR www.preparerCode %O", err)
    })
}

function cacheContenu(req, res, next) {
  res.append('Content-Encoding', 'gzip')
  res.type('json')

  // Caching
  res.append('Cache-Control', 'max-age=0')
  res.append('Cache-Control', 'stale-if-error=3600')
  res.append('Cache-Control', 'public')

  next()
}

function cacheRes(req, res, next) {

  const url = req.url
  debug("Cache res URL : %s", url)
  if(url.endsWith('.chunk.js') || url.endsWith('.chunk.css') ||
     url.endsWith('.chunk.js.map') || url.endsWith('.chunk.css.map')) {

       // Pour les .chunk.js, on peut faire un cache indefini (immutable)
    res.append('Cache-Control', 'max-age=86400')
    res.append('Cache-Control', 'immutable')

  } else {
    // Pour les autrres, faire un cachee limite (e.g. .worker.js, nom ne change pas)
    res.append('Cache-Control', 'max-age=60')
  }

  // res.append('Cache-Control', 'max-age=86400')
  res.append('Cache-Control', 'public')

  next()
}

async function initialiserDonnees(amqpdao, noeudId) {
  // Lancer chargement async des sites (si echec, va reessayer durant la maintenance)
  try {
    await Promise.all([
      chargerMapping(amqpdao, noeudId),
      chargerSections(amqpdao, noeudId),
    ])
  } catch(err) {
    console.error("Erreurs chargements site/sections: %O", err)
  }
}

async function initialiserRoutingKeys(rabbitMQ, noeudId, socketIo) {
  // Creer objets de connexion a MQ - importer librairies requises
  siteMessageHandler.init(rabbitMQ, noeudId, socketIo)
  await rabbitMQ.enregistrerListenerConnexion(siteMessageHandler)
}

// Demarrer le serveur
init()
